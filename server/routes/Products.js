const express = require("express");
const router = express.Router();
const { Products, AccountTypes, Sacco, Currency } = require("../models");
const { validateToken } = require("../middlewares/AuthMiddleware");
const { logViewOperation, logCreateOperation, logUpdateOperation, logDeleteOperation } = require("../middlewares/LoggingMiddleware");
const { Op } = require("sequelize");

const respond = (res, code, message, entity) => {
  res.status(code).json({ code, message, entity });
};

// List with optional status filter and search
router.get("/", validateToken, logViewOperation("Product"), async (req, res) => {
  try {
    const { status, q } = req.query;
    const where = { 
      isDeleted: 0,
      status: { [Op.ne]: "Deleted" } // Exclude deleted products
    };
    if (status) where.status = status;
    if (q) {
      where[Op.or] = [
        { productId: { [Op.like]: `%${q}%` } },
        { productName: { [Op.like]: `%${q}%` } },
        { productType: { [Op.like]: `%${q}%` } },
        { description: { [Op.like]: `%${q}%` } },
      ];
    }
    const products = await Products.findAll({ where, order: [["createdOn", "DESC"]] });
    respond(res, 200, "Products fetched", products);
  } catch (err) {
    respond(res, 500, err.message);
  }
});

// Get one
router.get("/:id", validateToken, logViewOperation("Product"), async (req, res) => {
  try {
    const product = await Products.findByPk(req.params.id);
    if (!product || product.isDeleted || product.status === "Deleted") return respond(res, 404, "Not found");
    respond(res, 200, "Product fetched", product);
  } catch (err) {
    respond(res, 500, err.message);
  }
});

// Create
router.post("/", validateToken, logCreateOperation("Product"), async (req, res) => {
  try {
    console.log("=== PRODUCT CREATION DEBUG ===");
    console.log("Request body:", JSON.stringify(req.body, null, 2));
    console.log("User:", req.user);
    
    const data = req.body || {};
    const username = req.user?.username || null;
    
    // Validate that the Sacco exists
    if (data.saccoId) {
      const sacco = await Sacco.findOne({ where: { saccoId: data.saccoId } });
      if (!sacco) {
        console.error(`Sacco with saccoId ${data.saccoId} not found`);
        return respond(res, 400, `Sacco with ID ${data.saccoId} not found`);
      }
      console.log(`Validated saccoId ${data.saccoId} exists`);
    }
    
    const payload = {
      // Only include productId if it's provided and not empty (will be auto-generated by model hook if not)
      ...(data.productId && data.productId.trim() !== '' && { productId: data.productId }),
      productName: data.productName,
      saccoId: data.saccoId,
      productType: data.productType || 'BOSA',
      productStatus: data.productStatus || "Pending",
      status: "Pending",
      description: data.description || null,
      isSpecial: data.isSpecial || false,
      maxSpecialUsers: data.maxSpecialUsers || null,
      // Account type fields
      accountType: data.accountType || 'MEMBER',
      bosaFosa: data.bosaFosa || 'BOSA',
      debitCredit: data.debitCredit || 'DEBIT',
      appliedOnMemberOnboarding: data.appliedOnMemberOnboarding || false,
      isWithdrawable: data.isWithdrawable !== undefined ? data.isWithdrawable : true,
      withdrawableFrom: data.withdrawableFrom || null,
      interestRate: data.interestRate || null,
      interestType: data.interestType || null,
      interestCalculationRule: data.interestCalculationRule || null,
      interestFrequency: data.interestFrequency || null,
      isCreditInterest: data.isCreditInterest || false,
      isDebitInterest: data.isDebitInterest || false,
      needGuarantors: data.needGuarantors || false,
      maxGuarantors: data.maxGuarantors || null,
      minGuarantors: data.minGuarantors || null,
      chargeIds: data.chargeIds || null,
      currency: data.currency || 'KES',
      createdOn: new Date(),
      createdBy: username,
    };
    
    console.log("Creating product with payload:", JSON.stringify(payload, null, 2));
    const created = await Products.create(payload);
    console.log("Product created successfully:", created.id);
    
    // Try to automatically create a default AccountType for this product
    let accountType = null;
    try {
      const generateAccountTypeId = (productId) => {
        const productDigits = productId.replace('P-', '');
        const randomNum = Math.floor(1000 + Math.random() * 9000);
        return `AT-${productDigits}${randomNum}`;
      };
      
      const accountTypePayload = {
        accountTypeId: generateAccountTypeId(created.productId),
        accountTypeName: `${created.productName} Account Type`,
        saccoId: data.saccoId,
        productId: created.id,
        accountType: 'MEMBER',
        bosaFosa: created.productType,
        debitCredit: 'DEBIT',
        appliedOnMemberOnboarding: false,
        isWithdrawable: true,
        withdrawableFrom: null,
        interestRate: null,
        interestType: null,
        interestCalculationRule: null,
        interestFrequency: null,
        chargeIds: null,
        currency: 'KES', // Default currency
        status: 'Draft',
        createdOn: new Date(),
        createdBy: username,
      };
      
      console.log("Creating account type with payload:", JSON.stringify(accountTypePayload, null, 2));
      accountType = await AccountTypes.create(accountTypePayload);
      console.log("Account type created successfully:", accountType.id);
    } catch (accountTypeError) {
      console.error("❌ ACCOUNT TYPE CREATION FAILED (AUTHENTICATED)");
      console.error("Error name:", accountTypeError.name);
      console.error("Error message:", accountTypeError.message);
      console.error("Error stack:", accountTypeError.stack);
      
      // Handle specific error types
      if (accountTypeError.name === 'SequelizeValidationError') {
        console.error("Validation errors:");
        accountTypeError.errors.forEach((error, index) => {
          console.error(`  ${index + 1}. Field: ${error.path}, Message: ${error.message}, Value: ${error.value}`);
        });
      } else if (accountTypeError.name === 'SequelizeUniqueConstraintError') {
        console.error("Unique constraint violation:");
        console.error("Fields:", accountTypeError.fields);
        console.error("Table:", accountTypeError.table);
      } else if (accountTypeError.name === 'SequelizeForeignKeyConstraintError') {
        console.error("Foreign key constraint error:");
        console.error("Table:", accountTypeError.table);
        console.error("Fields:", accountTypeError.fields);
        console.error("Value:", accountTypeError.value);
        console.error("Index:", accountTypeError.index);
      } else if (accountTypeError.name === 'SequelizeDatabaseError') {
        console.error("Database error:");
        console.error("SQL:", accountTypeError.sql);
        console.error("Parameters:", accountTypeError.parameters);
        if (accountTypeError.original) {
          console.error("Original error:", accountTypeError.original);
        }
      }
      
      console.error("Full error object:", JSON.stringify(accountTypeError, null, 2));
      // Continue without failing the product creation
    }
    
    // Return the created product directly in entity field (not wrapped)
    respond(res, 201, "Product created successfully", created);
  } catch (err) {
    console.error("=== PRODUCT CREATION ERROR ===");
    console.error("Error name:", err.name);
    console.error("Error message:", err.message);
    console.error("Full error:", err);
    
    // Map common Sequelize errors to client-friendly messages
    if (err?.name === 'SequelizeUniqueConstraintError') {
      return respond(res, 400, 'Product ID already exists');
    }
    if (err?.name === 'SequelizeValidationError') {
      const detail = err?.errors?.[0]?.message || 'Validation error';
      return respond(res, 400, detail);
    }
    respond(res, 500, err.message || 'Internal server error');
  }
});

// Update
router.put("/:id", validateToken, logUpdateOperation("Product"), async (req, res) => {
  try {
    const data = req.body || {};
    const username = req.user?.username || null;
    const updatePayload = {
      productId: data.productId,
      productName: data.productName,
      saccoId: data.saccoId,
      productType: data.productType,
      productStatus: data.productStatus,
      description: data.description,
      isSpecial: data.isSpecial,
      maxSpecialUsers: data.maxSpecialUsers,
      verifierRemarks: data.verifierRemarks,
      status: data.status,
      // Account type fields
      accountType: data.accountType,
      bosaFosa: data.bosaFosa,
      debitCredit: data.debitCredit,
      appliedOnMemberOnboarding: data.appliedOnMemberOnboarding,
      isWithdrawable: data.isWithdrawable,
      withdrawableFrom: data.withdrawableFrom,
      interestRate: data.interestRate,
      interestType: data.interestType,
      interestCalculationRule: data.interestCalculationRule,
      interestFrequency: data.interestFrequency,
      isCreditInterest: data.isCreditInterest,
      isDebitInterest: data.isDebitInterest,
      needGuarantors: data.needGuarantors,
      maxGuarantors: data.maxGuarantors,
      minGuarantors: data.minGuarantors,
      chargeIds: data.chargeIds,
      currency: data.currency,
      modifiedOn: new Date(),
      modifiedBy: username,
    };
    
    // Remove undefined values
    Object.keys(updatePayload).forEach(key => {
      if (updatePayload[key] === undefined) {
        delete updatePayload[key];
      }
    });
    
    const [count] = await Products.update(updatePayload, { 
      where: { 
        id: req.params.id, 
        isDeleted: 0,
        status: { [Op.ne]: "Deleted" }
      } 
    });
    if (!count) return respond(res, 404, "Not found");
    const updated = await Products.findByPk(req.params.id);
    respond(res, 200, "Product updated", updated);
  } catch (err) {
    respond(res, 500, err.message);
  }
});

// Soft delete
router.delete("/:id", validateToken, logDeleteOperation("Product"), async (req, res) => {
  try {
    const [count] = await Products.update({ 
      isDeleted: 1, 
      status: "Deleted",
      modifiedOn: new Date(),
      modifiedBy: req.user?.username || "System"
    }, { where: { id: req.params.id } });
    if (!count) return respond(res, 404, "Not found");
    respond(res, 200, "Product deleted");
  } catch (err) {
    respond(res, 500, err.message);
  }
});

module.exports = router;
